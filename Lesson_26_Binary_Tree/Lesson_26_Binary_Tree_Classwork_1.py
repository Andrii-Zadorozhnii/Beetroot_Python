class Node:
    """
    Класс для представления узла бинарного дерева.
    Каждый узел хранит значение и ссылки на левого и правого потомков.
    """

    def __init__(self, value):
        """
        Инициализация нового узла.

        :param value: Значение, которое будет храниться в узле.
        """
        self.value = value  # Значение узла
        self.left = None  # Левый потомок
        self.right = None  # Правый потомок


class BinaryTree:
    """
    Класс для представления бинарного дерева поиска.
    Дерево строится по принципу бинарного поиска, где для каждого узла:
    - элементы в левом поддереве меньше его значения,
    - элементы в правом поддереве больше.
    """

    def __init__(self):
        """
        Инициализация бинарного дерева.
        На начальном этапе дерево пустое.
        """
        self.root = None  # Корень дерева, инициализируем как None (пустое дерево)

    def insert(self, value):
        """
        Вставка нового элемента в бинарное дерево.
        Если дерево пустое, создается новый корень.
        Если дерево не пустое, элемент вставляется в соответствующее место.

        :param value: Значение, которое нужно вставить в дерево.
        """
        if self.root is None:
            self.root = Node(value)  # Если дерево пустое, создаем новый корень
        else:
            self._insert(self.root, value)  # Если дерево не пустое, вставляем элемент в дерево

    def _insert(self, current, value):
        """
        Вставка элемента в бинарное дерево на основе текущего узла.
        Это рекурсивная функция, которая находит подходящее место для нового элемента.

        :param current: Текущий узел, с которым сравниваем значение.
        :param value: Значение, которое нужно вставить в дерево.
        """
        if value < current.value:
            if current.left is None:
                current.left = Node(value)  # Если слева пусто, вставляем сюда
            else:
                self._insert(current.left, value)  # Иначе продолжаем искать в левом поддереве
        else:
            if current.right is None:
                current.right = Node(value)  # Если справа пусто, вставляем сюда
            else:
                self._insert(current.right, value)  # Иначе продолжаем искать в правом поддереве

    def inorder(self, node):
        """
        Обход дерева в порядке возрастания (in-order).
        Сначала обрабатываем левое поддерево, затем текущий узел, потом правое поддерево.

        :param node: Текущий узел для начала обхода.
        """
        if node:
            self.inorder(node.left)  # Рекурсивно проходим по левому поддереву
            print(node.value, end=' ')  # Печатаем значение текущего узла
            self.inorder(node.right)  # Рекурсивно проходим по правому поддереву


# Создаем экземпляр бинарного дерева
tree = BinaryTree()

# Список чисел для вставки в дерево
numbers = [5, 3, 8, 2, 4, 7, 9, 1, 6, 10]

# Вставляем числа в дерево
for num in numbers:
    tree.insert(num)

# Выводим элементы дерева в порядке возрастания (in-order)
print("Элементы бинарного дерева (in-order):")
tree.inorder(tree.root)

'''_________________________________________________________________________________________'''


class BinaryTree:
    """
    Класс для представления бинарного дерева, реализованного с использованием списка в списке.
    Каждый узел представлен в виде списка, где:
    - [0] — значение узла,
    - [1] — левый потомок,
    - [2] — правый потомок.
    """

    def __init__(self):
        """
        Инициализация бинарного дерева.
        Дерево будет храниться как список, изначально пустое.
        """
        self.tree = []  # Список для хранения дерева

    def insert(self, value):
        """
        Вставка нового элемента в бинарное дерево.
        Если дерево пустое, создается новый корень.
        Если дерево не пустое, элемент вставляется в соответствующее место.

        :param value: Значение, которое нужно вставить в дерево.
        """
        if not self.tree:
            self.tree = [value, [], []]  # Если дерево пустое, создаем новый корень
        else:
            self._insert(self.tree, value)  # Вставляем в дерево

    def _insert(self, current, value):
        """
        Вставка элемента в бинарное дерево на основе текущего узла.
        Это рекурсивная функция, которая находит подходящее место для нового элемента.

        :param current: Текущий узел (список), с которым сравниваем значение.
        :param value: Значение, которое нужно вставить в дерево.
        """
        if value < current[0]:
            if not current[1]:
                current[1] = [value, [], []]  # Если левый потомок пуст, вставляем сюда
            else:
                self._insert(current[1], value)  # Иначе продолжаем искать в левом поддереве
        else:
            if not current[2]:
                current[2] = [value, [], []]  # Если правый потомок пуст, вставляем сюда
            else:
                self._insert(current[2], value)  # Иначе продолжаем искать в правом поддереве

    def inorder(self, node):
        """
        Обход дерева в порядке возрастания (in-order).
        Сначала обрабатываем левое поддерево, затем текущий узел, потом правое поддерево.

        :param node: Текущий узел для начала обхода.
        """
        if node:
            self.inorder(node[1])  # Рекурсивно проходим по левому поддереву
            print(node[0], end=' ')  # Печатаем значение текущего узла
            self.inorder(node[2])  # Рекурсивно проходим по правому поддереву


# Создаем экземпляр бинарного дерева
tree = BinaryTree()

# Список чисел для вставки в дерево
numbers = [5, 3, 8, 2, 4, 7, 9, 1, 6, 10]

# Вставляем числа в дерево
for num in numbers:
    tree.insert(num)

# Выводим элементы дерева в порядке возрастания (in-order)
print("Элементы бинарного дерева (in-order):")
tree.inorder(tree.tree)
