# Бинарное дерево, представленное в виде списка:
# Каждый узел представлен списком, где:
# - [0] — значение узла,
# - [1] — левый потомок,
# - [2] — правый потомок.

# Инициализация корня дерева с элементом 5
tree = [5, [], []]


# Функция для вставки элемента в левую часть дерева
def insert_left(tree: list, number: int) -> None:
    """
    Вставка элемента в левую часть дерева.
    Если левая часть дерева пуста, создается новый узел.
    Если левая часть дерева уже содержит узел, то новый элемент становится левым потомком,
    а старое левое поддерево становится левым потомком нового узла.

    :param tree: Текущий узел дерева, в который будем вставлять.
    :param number: Значение, которое нужно вставить в левую часть дерева.
    """
    if not tree[1]:  # Если левая часть дерева пуста
        tree[1] = [number, [], []]  # Создаем новый узел в левой части
        print(tree)  # Выводим дерево после вставки
    else:
        value = tree[1]  # Запоминаем левое поддерево
        tree[1] = [number, value, []]  # Вставляем новый узел, левое поддерево становится его левым потомком
        print(tree)  # Выводим дерево после вставки


# Функция для вставки элемента в правую часть дерева
def insert_right(tree: list, number: int) -> None:
    """
    Вставка элемента в правую часть дерева.
    Если правая часть дерева пуста, создается новый узел.
    Если правая часть дерева уже содержит узел, то новый элемент становится правым потомком,
    а старое правое поддерево становится правым потомком нового узла.

    :param tree: Текущий узел дерева, в который будем вставлять.
    :param number: Значение, которое нужно вставить в правую часть дерева.
    """
    if not tree[2]:  # Если правая часть дерева пуста
        tree[2] = [number, [], []]  # Создаем новый узел в правой части
        print(tree)  # Выводим дерево после вставки
    else:
        value = tree[2]  # Запоминаем правое поддерево
        tree[2] = [number, [], value]  # Вставляем новый узел, правое поддерево становится его правым потомком
        print(tree)  # Выводим дерево после вставки


# Функция для добавления нового узла в дерево (по умолчанию это создаст новый корень)
def create_0_element(tree: list, number: int) -> None:
    """
    Создание нового элемента в дереве. Новый элемент станет корнем дерева.

    :param tree: Текущее дерево.
    :param number: Значение, которое нужно вставить в корень.
    """
    tree.extend([number, [], []])  # Добавляем новый узел в дерево


# Функция для получения значения текущего узла
def get_route(tree: list) -> int:
    """
    Получение значения текущего узла.

    :param tree: Текущее дерево.
    :return: Значение текущего узла.
    """
    return tree[0]


# Функция для получения левого потомка текущего узла
def get_left_children(tree: list) -> list:
    """
    Получение левого потомка текущего узла.

    :param tree: Текущее дерево.
    :return: Левый потомок текущего узла.
    """
    return tree[1]


# Функция для получения правого потомка текущего узла
def get_right_children(tree: list) -> list:
    """
    Получение правого потомка текущего узла.

    :param tree: Текущее дерево.
    :return: Правый потомок текущего узла.
    """
    return tree[2]


# Функция для изменения значения текущего узла
def change_route(tree: list, number: int) -> None:
    """
    Изменение значения текущего узла.

    :param tree: Текущее дерево.
    :param number: Новое значение для текущего узла.
    """
    tree[0] = number  # Устанавливаем новое значение для текущего узла


# Вставляем элементы в левую и правую части дерева
insert_left(tree, 4)
insert_right(tree, 8)

# Меняем значение корня на 10
change_route(tree, 10)

# Выводим дерево на первом уровне
print("Дерево после изменений:")
print(tree)

# Получаем левый потомок корня
left_second_level = get_left_children(get_left_children(tree))
print("Левый потомок второго уровня:")
print(left_second_level)

# Добавляем элемент в левый потомок второго уровня
create_0_element(left_second_level, 6)

# Выводим дерево после добавления нового элемента
print("Дерево после добавления нового элемента:")
print(tree)

# Получаем правый потомок корня (если нужно)
right_second_level = get_right_children(tree)
print("Правый потомок первого уровня:")
print(right_second_level)
